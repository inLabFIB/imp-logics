# Developers guide

## Project structure

The code is organized as follows:

- `dependencyschema.domain`: contains the entities that represents the logic objects of a dependency schema.
- `dependencyschema.services`: contains the services that operates over such entities:
  - `dependencyschema.services.creation`: contains the services related to creating a logic schema
  - `dependencyschema.services.parser`: contains the service of parsing
  - `dependencyschema.services.printer`: contains the service of printing
  - `dependencyschema.services.analyzer`: contains some services for applying usefull analysis over dependency schemas.
    schemas (e.g. unfolding).
  - `dependencyschema.services.processes`: contains some services for applying usefull equivalent transformations in
    logic

- `logicschema.domain`: contains the entities that represents the logic objects of a Datalog program
- `logicschema.services`: contains the services that operates over such entities:
  - `logicschema.services.creation`: contains the services related to creating a logic schema
  - `logicschema.services.parser`: contains the service of parsing
  - `logicschema.services.printer`: contains the service of printing
  - `logicschema.services.comparator`: contains the service for analyzing the equivalence between two normal clauses
  - `logicschema.services.processes`: contains some services for applying usefull equivalent transformations in logic
    schemas (e.g. unfolding).

On the following, we pay special attention to the LogicSchema part of the library.

## Guidance for creating a LogicSchema or DependencySchema

Terms are Value Objects, so, they can be reused among several constructions. E.g, a variable term "x" can
be reused in several atoms, or built-in literals, even from different schemas.

Predicates are Entities (since they are identified by their name).
They can be reused to create several atoms inside the schema they belong to, but should not be used in different
schemas.

Atoms, and Literals should not be reused in several NormalClauses (or Dependencies),
neither twice in the same NormalClause (or Dependency).
This is because they are not value objects, but entities. Indeed, they cannot be value objects since they contain
predicates, which are entities.

## Guidance for extending DatalogPlusMinusAnalyzer to identify new Datalog+/- languages

DatalogPlusMinusAnalyzer is the class in charge of identifying the specific Datalog+/-
language some dependency schema is written in (e.g. *linear*, *guarded*, etc).

In case you want to extend such Analyzer to identify a new Datalog+/- language, please,
proceed as follows:

1. Extend the enumeration from DatalogPlusMinusAnalyzer::DatalogPlusMinusLanguage to include your language.
2. Implement a new subclass of DatalogPlusMinusLanguageChecker and implement its abstract methods.
3. Instantiate such new subclass in the structure DatalogPlusMinusAnalyzer::datalogCheckers

## Guidance for creating equals & hashcode

When automatically generating the functions equals & hashcode, we prefer using the Java proposals rather than
the IDE based equals & hashcode.

## Testing code

### To test or not to test

- Setters, getters, and similar trivial functions won't be tested unless they include additional logic
- Private methods will be considered implementation details, and won't be tested
- Equals & hashCodes that are trivial (generated by the IDE) won't be tested either

### Test Naming Conventions

Taking inspiration from https://dzone.com/articles/7-popular-unit-test-naming we use the following convention:

**should_featureTested_whenStateUnderTest**

